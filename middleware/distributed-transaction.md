# 分布式事务
## 数据库事务
>### ACID
* Atomicity 原子性  
事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。
* Consistency 一致性  
事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态
* Isolation 隔离性  
并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样
* Durability 持久性  
事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。

## 理论
>### CAP定理  
一个分布式系统不可能同时满足这3个条件，最多只能满足其中两项，要么 AP，要么 CP，要么 AC，但是不存在 CAP  
* 一致性 Consistency
* 可用性 Availability
* 分区容错性 Partition torebalance  
*如Eureka满足AP*  
*如Zookeeper满足CP*  

>### BASE定理  
为了用户体验，先选可用性。现在只能在一致性和可用性之间做选择，大部分情况下，大家都会选择牺牲一部分的一致性来保证可用性，因为你不返回给用户数据，这体验也太差了，宁可拒绝服务也不能说能访问却没有数据，当然，严格场景下，比如支付场景，强一致性是必须要满足，这另说。  
但是放弃了一致性的系统又失去了存在的意义，好了，我们只能放弃一致性，但是我们真这样做了，将一致性放弃了，现在这个系统返回的数据你敢信吗？没有一致性，系统中的数据也就从根本上变得不可信了，那这数据拿来有什么用，那这个系统也就没有任何价值，根本没用。  
如上所述，由于我们三者都无法抛弃，但CAP定理限制了我们三者无法同时满足，这种情况，我们会选择尽量靠近CAP定理，即尽量让C、A、P都满足，在此大势所趋下，出现了BASE定理。  
**核心思想:** 强一致性（Strong consistency）无法得到保障时（分区容错和可用性满足系统），我们可以根据业务自身的特点，采用适当的方式来达到最终一致性（Eventual consistency）。
* 基本可用 Basic Available
* 软状态 Soft State
* 最终一致性 Eventually Consistency   

## 2PC 
> [参考]<https://www.cnblogs.com/johnvwan/p/15571276.html>  

*2PC是一个非常经典的强一致、中心化的原子提交协议。中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和N个参与者节点（partcipant）*

### 过程
1. **准备阶段**
   1. 事务询问：协调者向所有参与者发送事务预处理请求Prepare，并开始等待各参与者的响应
   2. 执行本地事务：各参与者执行本地事务操作，但在执行本地事务时不会真正提交本地事务，而是先向协调者报告说："我可以执行/我不能执行"
   3. 各参与者向协调者反馈事务的响应：如果参与者事务预执行成功，则给协调者Yes响应；如果没有参与者事务预执行失败，则给协调者No响应。
2. **提交阶段-正常提交**
   1. 协调者通知所有参与者Commit事务请求
   2. 参与者收到Commit请求后，正式执行本地事务Commit操作，并在完成之后释放整个事务期间占用的事务资源
3. **提交阶段-异常回滚**
   1. 协调者通知所有参与者Rollback事务请求
   2. 参与者收到Rollback请求之后，就会正式执行本地事务Rollback操作，并在完成提交之后释放整个事务执行期间占用的事务资源。

### 缺点
* **性能问题**  
  无论是在第一阶段的过程中,还是在第二阶段,所有的参与者资源和协调者资源都是被锁住的,只有当所有节点准备完毕，事务 协调者 才会通知进行全局提交，参与者进行本地事务提交后才会释放资源。这样的过程会比较漫长，对性能影响比较大
* **单节点故障**  
  由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（虽然协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）。
* **数据一致性**  
  在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致


## 3PC
> [参考]<https://www.cnblogs.com/johnvwan/p/15571296.html>  

*3PC是2PC的改进版本，3PC主要是为了解决2PC的阻塞问题，2PC存在的问题是当协调者崩溃时，参与者不能做出最后的选择。因此参与者可能在协调者恢复之前保持阻塞。*  

### 相比2PC，3PC的改动点
* 引入超时机制。同时在协调者和参与者中都引入超时机制；
* 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

### 过程
1. **CanCommit**  
*2PC的一阶段是本地事务执行结束后不 Commit 而返回 Yes，由协调者通知commit才真正执行commit。而这里的CanCommit指的是 尝试获取数据库锁 如果可以，就返回Yes*
   1. 事务询问：协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应
   2. 响应反馈：参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No
2. **PreCommit - 预提交**  
*在阶段一中，如果所有参与者返回Yes，则进入PreCommit阶段进行事务预提交。PreCommit阶段跟上面的第一阶段是差不多的，只不过这里协调者和参与者都引入了超时机制（2PC中只有协调者可以超时，参与者没有超时机制）*
   1. 事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中
   2. 响应反馈：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令
3. **PreCommit - 预提交中断**  
*在阶段一中，如果有任何一个参与者返回No，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断*
   1. 发送中断请求：协调者向所有参与者发送abort请求。
   2. 中断事务：参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。
4. **DoCommit - 正式提交**  
*该阶段进行真正的事务提交*
   1. 事务提交：参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
   2. 响应反馈：事务提交完之后，向协调者发送Ack响应。
   3. 完成事务：协调者接收到所有参与者的ack响应之后，完成事务。
5. **DoCommit - 中断**
   1. 发送中断请求：协调者向所有参与者发送abort请求
   2. 事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
   3. 反馈结果：参与者完成事务回滚之后，向协调者发送ACK消息
   4. 中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。

### 缺点

## TCC
*Try-Confirm-Cancel*
>[子事务屏障]<https://segmentfault.com/a/1190000040321750>

### 过程
1. Try：预留业务资源/数据效验
2. Confirm：确认执行业务操作
3. Cancel：取消执行业务操作

### 缺点
* **业务侵入**  
业务逻辑的每个分支都需要实现 Try、Conﬁrm、Cancel 三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略

### 优点
* **业务灵活**  
应用可以自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能
   
### 异常情况
* **空回滚**  
**问题：** 在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。  
**出现原因：** 是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行 Try 阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的 Cancel 方法，从而形成空回滚。

* **防悬挂**  
**问题：** 分布式事务的二阶段 Cancel 接口比 Try 接口先执行  
**出现原因：** 出现原因是在 RPC 调用分支事务 Try 时，先注册分支事务，再执行 RPC 调用，如果此时 RPC 调用的网络发生拥堵，通常 RPC 调用是有超时时间的，RPC 超时以后，TM 就会通知 RM 回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行，而一个 Try 方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就称为悬挂，即业务资源预留后没法继续处理。  
**解决思路：** 是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，"分支事务记录"表中是否已经有二阶段事务记录，如果有则不执行 Try

* **幂等**
为了保证 TCC 重试机制不会引发数据不一致，要求 TCC 的二阶段 Try、Conﬁrm 和 Cancel 接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题

空回滚、悬挂、幂等，可通过[子事务屏障](https://segmentfault.com/a/1190000040321750)解决

## 最大努力通知
*最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知等*

## 最终一致性
> 需要解决的问题
>* 本地事务和消息发送的原子性
>* 事务参与方接受消息的可靠性
>* 重复消费
### 解决方案  
* 本地消息表  
> 通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。

* 事务消息  
将本地消息表放到服务端，如阿里的RocketMQ  
> **过程：**  
>* 发送消息  
>* 服务端存储消息，并响应写入结果  
>* 根据发送结果执行本地事务
>* 根据本地事务状态执行消息的commit或rollback  
**补偿：** 对于没有执行commit或rollback的，从服务端发起一次"回查"